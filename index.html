<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>OCR Парсер NBA 2K — счёт, фора, тотал, прогноз</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; max-width: 960px; margin:24px auto; padding:0 16px; color:#222; background:#f5f7fb; }
    .card { background:white; border-radius:12px; padding:18px; box-shadow:0 6px 20px rgba(20,30,60,0.06); margin-bottom:18px; }
    h1 { color:#123061; margin:0 0 10px 0; font-size:20px; }
    input[type=file] { display:inline-block; }
    button { background:#2563eb; color:white; border:0; padding:10px 14px; border-radius:8px; cursor:pointer; margin-left:8px; font-weight:600; }
    button:disabled { opacity:.5; cursor:not-allowed; }
    #preview { max-width:100%; margin-top:12px; border-radius:8px; border:1px solid #e6eefc; }
    .log { background:#fbfdff; border:1px solid #eef4ff; padding:12px; border-radius:8px; font-family:monospace; white-space:pre-wrap; }
    table { border-collapse:collapse; width:100%; margin-top:12px; }
    th, td { border:1px solid #e6eefc; padding:8px 10px; text-align:left; }
    th { background:#f0f7ff; }
    .stat { font-size:18px; margin:8px 0; }
    .label { color:#475569; font-size:13px; }
    .highlight { font-weight:700; color:#0b3b6f; }
    .small { font-size:13px; color:#64748b; }
  </style>
</head>
<body>
  <div class="card">
    <h1>Парсер скринов NBA 2K / ESportsBattle — счёт, фора, тотал, прогноз</h1>
    <input id="file" type="file" accept="image/*">
    <button id="run" disabled>Распознать и посчитать</button>
    <span id="status" class="small" style="margin-left:12px">Выберите изображение</span>
    <div>
      <img id="preview" alt="preview" />
    </div>
    <div class="small" style="margin-top:8px">Совет: загружай целые, чёткие скрины (не слишком маленькие).</div>
  </div>

  <div class="card">
    <h3>Распознанный текст</h3>
    <div id="rawText" class="log">Ожидание...</div>
  </div>

  <div class="card">
    <h3>Результаты и прогноз</h3>
    <div id="output"></div>
  </div>

  <!-- Используем проверенную версию Tesseract v5 -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.1.0/dist/tesseract.min.js"></script>

  <script>
  const fileInput = document.getElementById('file');
  const preview = document.getElementById('preview');
  const runBtn = document.getElementById('run');
  const status = document.getElementById('status');
  const rawTextEl = document.getElementById('rawText');
  const outputEl = document.getElementById('output');

  let currentFile = null;

  fileInput.addEventListener('change', e => {
    const f = e.target.files[0];
    if (!f) return;
    currentFile = f;
    preview.src = URL.createObjectURL(f);
    runBtn.disabled = false;
    status.textContent = 'Готово — нажми "Распознать и посчитать"';
    rawTextEl.textContent = 'Ожидание...';
    outputEl.innerHTML = '';
  });

  runBtn.addEventListener('click', async () => {
    if (!currentFile) return;
    runBtn.disabled = true;
    status.textContent = 'Подготовка изображения...';
    rawTextEl.textContent = '...';
    outputEl.innerHTML = '';

    try {
      // 1) Преобразуем файл в dataURL
      const reader = new FileReader();
      reader.readAsDataURL(currentFile);
      await new Promise(res => reader.onload = res);
      const dataUrl = reader.result;

      // 2) Предобработка: увеличим + контраст/грэйскейл для лучшего OCR
      status.textContent = 'Предобработка изображения...';
      const img = await createImage(dataUrl);
      const preprocessedDataUrl = preprocess(img, 2.0, 1.2, 1.05); // scale, contrast, brightness

      // 3) Запустить OCR (rus+eng)
      status.textContent = 'Запуск OCR...';
      const { data: { text } } = await Tesseract.recognize(preprocessedDataUrl, 'rus+eng', {
        logger: m => {
          if (m.status && m.progress != null) status.textContent = `${m.status}: ${(m.progress*100).toFixed(0)}%`;
        },
        // можно добавить whitelist, но оставим гибким
      });

      rawTextEl.textContent = text.trim() || '(пусто)';
      status.textContent = 'Парсинг данных...';

      // 4) Парсим матч
      const parsed = parseMatch(text);
      // 5) Считаем прогноз
      const withForecast = computeForecast(parsed);
      // 6) Рендерим
      renderOutput(withForecast);

      status.textContent = 'Готово ✅';
    } catch (err) {
      console.error(err);
      rawTextEl.textContent = err.message || String(err);
      status.textContent = 'Ошибка: ' + (err.message || err);
    } finally {
      runBtn.disabled = false;
    }
  });

  // -------------------- utilities --------------------
  function createImage(dataUrl) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = reject;
      img.src = dataUrl;
    });
  }

  function preprocess(img, scale=2.0, contrast=1.2, brightness=1.0) {
    const c = document.createElement('canvas');
    c.width = Math.round(img.width * scale);
    c.height = Math.round(img.height * scale);
    const ctx = c.getContext('2d');
    // apply CSS filter before drawing
    ctx.filter = `grayscale(1) contrast(${contrast}) brightness(${brightness})`;
    ctx.drawImage(img, 0, 0, c.width, c.height);
    // try slight local enhancement: increase sharpness via putImageData not implemented for simplicity
    return c.toDataURL('image/png', 0.9);
  }

  // -------------------- парсер --------------------
  function parseMatch(rawText) {
    const lines = (rawText||'').split(/\r?\n/).map(l=>l.replace(/\u00A0/g,' ').trim()).filter(Boolean);
    const joined = lines.join(' | ');
    const res = {
      rawLines: lines,
      format: null, // 4x5 or 4x4
      timeBlock: null, // { clock, quarter, timeRemainingRaw, minutesRemainingInQuarter }
      team1: { name: null, perQuarter: [], total: null },
      team2: { name: null, perQuarter: [], total: null },
      totalLine: null, // extracted TM/TB e.g. { tm:127.5, tb:127.5 }
      handicap: null // e.g. { f1:'+4.5', f2:'-4.5' }
    };

    // format
    const mformat = joined.match(/(\d)\s*[x×]\s*(\d)\s*мин/i);
    if (mformat) res.format = `${mformat[1]}x${mformat[2]}`;
    else if (/4\s*[x×]\s*5/i.test(joined)) res.format = '4x5';
    else if (/4\s*[x×]\s*4/i.test(joined)) res.format = '4x4';
    else res.format = '4x5'; // fallback

    // time/quarter detection:
    // examples: "19:39 | 2-я четверть, 05:00" or "3-я четверть 04:39" or "2-я четверть 05:00"
    for (const l of lines) {
      const qMatch = l.match(/([1-4])\s*[-–]?\s*я\s*четверть/i) || l.match(/([1-4])\s*четверть/i);
      const clockMatch = l.match(/(\d{1,2}:\d{2})/);
      const timeRemMatch = l.match(/([0-5]?\d:[0-5]?\d)/g); // may be two times; pick the latter as remaining
      if (qMatch) {
        const quarter = Number(qMatch[1]);
        let timeRemaining = null;
        // prefer a colon time after quarter
        if (timeRemMatch && timeRemMatch.length>0) {
          // choose last occurrence
          timeRemaining = timeRemMatch[timeRemMatch.length-1];
        } else if (clockMatch) {
          // if only clock is present, could be current clock - but most useful is remaining in quarter if exists
          timeRemaining = null;
        }
        res.timeBlock = { clock: clockMatch ? clockMatch[1] : null, quarter, timeRemainingRaw: timeRemaining };
        break;
      }
      // fallback: if line contains 'четверть' and a time
      if (/четверть/i.test(l) && (timeRemMatch && timeRemMatch.length>0)) {
        res.timeBlock = { clock: clockMatch ? clockMatch[1] : null, quarter: parseInt((l.match(/[1-4]/)||[])[0]) || null, timeRemainingRaw: timeRemMatch[timeRemMatch.length-1] };
        break;
      }
    }

    // extract candidate lines containing team + numbers
    // Some OCR can split name and numbers; handle both: lines with >=2 numbers OR adjacent name + numbers
    const numberSeq = /\d{1,3}/g;
    const candidates = [];
    for (let i=0;i<lines.length;i++) {
      const l = lines[i];
      const nums = (l.match(numberSeq) || []).map(Number);
      if (nums.length >= 2) {
        // contains numbers (likely per-quarter + total or quarters)
        candidates.push({ idx:i, line:l, nums });
      } else {
        // check next line for numbers: name line preceding numbers line
        if (i < lines.length-1) {
          const nextNums = (lines[i+1].match(numberSeq) || []).map(Number);
          if (nextNums.length >= 2) {
            candidates.push({ idx:i, line: l + ' ' + lines[i+1], nums: nextNums, merged:true });
          }
        }
      }
    }

    // pick top two candidate teams (in original order)
    candidates.sort((a,b)=>a.idx - b.idx);
    if (candidates.length >= 2) {
      const t1 = candidates[0], t2 = candidates[1];
      res.team1.name = extractNameFromLine(t1.line);
      res.team1.perQuarter = t1.nums.slice(0, -1);
      res.team1.total = t1.nums[t1.nums.length - 1];
      res.team2.name = extractNameFromLine(t2.line);
      res.team2.perQuarter = t2.nums.slice(0, -1);
      res.team2.total = t2.nums[t2.nums.length - 1];
    } else {
      // try looser extraction: find any two lines that end with a boxed total (OCR may keep it)
      for (const l of lines) {
        const nums = (l.match(numberSeq) || []).map(Number);
        if (nums.length >= 1) {
          // push as possible
          candidates.push({ idx:lines.indexOf(l), line:l, nums });
        }
      }
      if (candidates.length >= 2) {
        const t1 = candidates[0], t2 = candidates[1];
        res.team1.name = extractNameFromLine(t1.line);
        res.team1.total = t1.nums.at(-1) || null;
        res.team2.name = extractNameFromLine(t2.line);
        res.team2.total = t2.nums.at(-1) || null;
      }
    }

    // extract total line (ТМ / ТБ)
    for (const l of lines) {
      // common patterns: "ТМ (127.5) 1.81 ТБ (127.5) 1.85" or "TM (127.5) 1.81"
      const tm = l.match(/ТМ\s*\(?\s*([\d.]+)\s*\)?/i) || l.match(/TM\s*\(?\s*([\d.]+)\s*\)?/i);
      const tb = l.match(/ТБ\s*\(?\s*([\d.]+)\s*\)?/i) || l.match(/TB\s*\(?\s*([\d.]+)\s*\)?/i);
      if (tm || tb) {
        res.totalLine = { tm: tm ? parseFloat(tm[1]) : null, tb: tb ? parseFloat(tb[1]) : null, raw: l };
        break;
      }
    }

    // extract handicap (Фора)
    for (const l of lines) {
      // patterns like: "Ф1 (+4.5) 1.78 Ф2 (-4.5) 1.88"
      const f1 = l.match(/Ф1\s*\(?\s*([+\-]?\d+(\.\d+)?)\s*\)?/i);
      const f2 = l.match(/Ф2\s*\(?\s*([+\-]?\d+(\.\d+)?)\s*\)?/i);
      if (f1 || f2) {
        res.handicap = {
          f1: f1 ? f1[1] : null,
          f2: f2 ? f2[1] : null,
          raw: l
        };
        break;
      }
    }

    return res;
  }

  function extractNameFromLine(line) {
    // remove numbers and odds-looking tokens and punctuation. Keep letters and parentheses (nicknames)
    let s = line.replace(/\d+/g, '').replace(/[✦★\[\]\|]/g,' ').replace(/\s{2,}/g,' ').trim();
    // Remove trailing punctuation like ':' ',' etc
    s = s.replace(/[,.:;]+$/,'').trim();
    return s || line;
  }

  // ------------------ Forecast computation ------------------
  function computeForecast(parsed) {
    // derive quarter length
    const quarterLen = (parsed.format === '4x4') ? 4 : 5;
    const totalGameMinutes = quarterLen * 4;

    // current total
    const score1 = Number(parsed.team1.total) || 0;
    const score2 = Number(parsed.team2.total) || 0;
    const currentTotal = score1 + score2;

    // determine minutes played
    let minutesPlayed = 0;
    let minutesRemaining = totalGameMinutes;

    if (parsed.timeBlock && parsed.timeBlock.quarter) {
      const q = Number(parsed.timeBlock.quarter) || 0;
      let timeRem = parsed.timeBlock.timeRemainingRaw;
      let quarterMinutesRemaining = quarterLen; // if unknown, assume full quarter remains (safe)
      if (timeRem && /:/.test(timeRem)) {
        const [mmStr, ssStr] = timeRem.split(':');
        const mm = Number(mmStr) || 0;
        const ss = Number(ssStr) || 0;
        quarterMinutesRemaining = mm + ss/60;
      } else {
        // if no timeRemaining given, try to infer from clock or assume half quarter remaining
        quarterMinutesRemaining = quarterLen / 2;
      }
      const completedQuarters = Math.max(0, q - 1);
      minutesPlayed = completedQuarters * quarterLen + Math.max(0, (quarterLen - quarterMinutesRemaining));
      minutesRemaining = Math.max(0, totalGameMinutes - minutesPlayed);
    } else {
      // If no quarter info, attempt to infer by how many perQuarter entries we have
      const pq1 = parsed.team1.perQuarter || [];
      const completedQuarters = pq1.length;
      minutesPlayed = completedQuarters * quarterLen;
      minutesRemaining = Math.max(0, totalGameMinutes - minutesPlayed);
    }

    // compute tempo (points per minute)
    let tempo = 0;
    if (minutesPlayed > 0) {
      tempo = currentTotal / minutesPlayed;
    } else {
      // fallback: if no minutes info, compute tempo from perQuarter data (if present)
      const pq1 = parsed.team1.perQuarter || [], pq2 = parsed.team2.perQuarter || [];
      const playedQuarters = Math.max(pq1.length, pq2.length);
      if (playedQuarters > 0) {
        const sumPQ = (pq1.concat(pq2)).map(n=>Number(n)||0).reduce((a,b)=>a+b,0);
        const minutes = playedQuarters * quarterLen;
        tempo = minutes>0 ? sumPQ / minutes : 0;
      } else {
        // last resort: assume average tempo ~ 2.0 points/min (very conservative)
        tempo = 2.0;
      }
    }

    // projected remaining points and totals
    const projectedRemaining = Math.round(tempo * minutesRemaining);
    const projectedTotal = Math.round(currentTotal + projectedRemaining);
    const projectedNextQuarter = Math.round(tempo * quarterLen);

    return {
      parsed,
      quarterLen,
      minutesPlayed: Number(minutesPlayed.toFixed(2)),
      minutesRemaining: Number(minutesRemaining.toFixed(2)),
      tempo: Number(tempo.toFixed(3)),
      currentTotal,
      projectedRemaining,
      projectedTotal,
      projectedNextQuarter
    };
  }

  // ------------------ render ------------------
  function renderOutput(data) {
    const p = data.parsed;
    const lines = [];
    lines.push(`<div class="stat"><span class="label">Команда 1:</span> <span class="highlight">${escapeHtml(p.team1.name || '—')}</span> — <strong>${p.team1.total ?? 0}</strong></div>`);
    lines.push(`<div class="stat"><span class="label">Команда 2:</span> <span class="highlight">${escapeHtml(p.team2.name || '—')}</span> — <strong>${p.team2.total ?? 0}</strong></div>`);
    lines.push(`<div class="stat"><span class="label">Общий тотал сейчас:</span> <strong>${data.currentTotal}</strong></div>`);

    if (p.totalLine) {
      const tm = p.totalLine.tm != null ? p.totalLine.tm : '';
      const tb = p.totalLine.tb != null ? p.totalLine.tb : '';
      lines.push(`<div class="stat"><span class="label">Линия тотала:</span> <strong>ТМ(${tm}) / ТБ(${tb})</strong></div>`);
    } else {
      lines.push(`<div class="stat"><span class="label">Линия тотала:</span> <em>не найдена</em></div>`);
    }

    if (p.handicap) {
      lines.push(`<div class="stat"><span class="label">Фора:</span> <strong>Ф1(${p.handicap.f1 || '-'}) / Ф2(${p.handicap.f2 || '-'})</strong></div>`);
    } else {
      lines.push(`<div class="stat"><span class="label">Фора:</span> <em>не найдена</em></div>`);
    }

    lines.push(`<div class="stat"><span class="label">Сыграно минут:</span> <strong>${data.minutesPlayed}</strong></div>`);
    lines.push(`<div class="stat"><span class="label">Осталось минут:</span> <strong>${data.minutesRemaining}</strong></div>`);
    lines.push(`<div class="stat"><span class="label">Темп (очков/мин):</span> <strong>${data.tempo}</strong></div>`);

    lines.push(`<div style="margin-top:12px" class="stat"><span class="label">Прогнозируемый остаток очков:</span> <strong>${data.projectedRemaining}</strong></div>`);
    lines.push(`<div class="stat"><span class="label">Прогнозируемый итоговый тотал:</span> <strong style="font-size:20px">${data.projectedTotal}</strong></div>`);
    lines.push(`<div class="stat"><span class="label">Прогноз тотала следующей четверти:</span> <strong>${data.projectedNextQuarter}</strong></div>`);

    // show raw lines for debugging and verification
    lines.push(`<details style="margin-top:12px"><summary class="small">Показать распознанные строки (отладка)</summary><pre class="small">${escapeHtml(p.rawLines.join('\n'))}</pre></details>`);

    outputEl.innerHTML = lines.join('\n');
  }

  function escapeHtml(s) {
    return String(s || '').replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
  }

  </script>
</body>
</html>
