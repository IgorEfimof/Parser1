<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>OCR — надёжное распознавание счёта (улучшено)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; max-width:900px; margin:24px auto; padding:0 16px; color:#222; background:#f5f7fb; }
    .card { background:white; border-radius:12px; padding:18px; box-shadow:0 6px 20px rgba(20,30,60,0.06); margin-bottom:18px; }
    button { background:#2563eb; color:white; border:0; padding:10px 14px; border-radius:8px; cursor:pointer; margin-left:8px; font-weight:600; }
    #preview { max-width:100%; margin-top:12px; border-radius:8px; border:1px solid #e6eefc; display:block; }
    .result { font-size:18px; margin-top:12px; }
    .ok { color:green; font-weight:700; }
  </style>
</head>
<body>
  <div class="card">
    <h2>Распознать счёт (улучшенная версия)</h2>
    <input id="file" type="file" accept="image/*">
    <button id="run" disabled>Распознать</button>
    <span id="status" style="margin-left:12px;color:#555;">Выберите изображение</span>
    <img id="preview" alt="preview" />
  </div>

  <div class="card">
    <h3>Результат</h3>
    <div id="output" class="result">Пока нет данных</div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.1.0/dist/tesseract.min.js"></script>
  <script>
    const fileInput = document.getElementById('file');
    const runBtn = document.getElementById('run');
    const preview = document.getElementById('preview');
    const status = document.getElementById('status');
    const output = document.getElementById('output');
    let currentFile = null;

    fileInput.addEventListener('change', e => {
      const f = e.target.files[0];
      if (!f) return;
      currentFile = f;
      preview.src = URL.createObjectURL(f);
      runBtn.disabled = false;
      status.textContent = 'Готово — нажми "Распознать"';
      output.textContent = 'Пока нет данных';
    });

    runBtn.addEventListener('click', async () => {
      if (!currentFile) return;
      runBtn.disabled = true;
      status.textContent = 'Подготовка изображения...';
      output.textContent = '...';

      try {
        const reader = new FileReader();
        reader.readAsDataURL(currentFile);
        await new Promise(res => reader.onload = res);
        const dataUrl = reader.result;

        // Предобработка: масштаб, кроп верхней части, контраст
        const pre = await preprocessAndCropTop(dataUrl, { scale: 2.0, topRatio: 0.45, contrast: 1.45, brightness: 1.05 });
        status.textContent = 'Запуск OCR...';

        const res = await Tesseract.recognize(pre.dataUrl, 'rus+eng', {
          logger: m => {
            if (m.status && m.progress != null) status.textContent = `${m.status}: ${(m.progress*100).toFixed(0)}%`;
          }
        });

        // распарсим на основе слов и bbox
        const parsed = extractScoresFromTess(res, pre.width, pre.height);
        renderResult(parsed);
        status.textContent = 'Готово ✅';
      } catch (err) {
        console.error(err);
        status.textContent = 'Ошибка';
        output.textContent = String(err);
      } finally {
        runBtn.disabled = false;
      }
    });

    // -------------------- предобработка и кроп --------------------
    async function preprocessAndCropTop(dataUrl, opts = {}) {
      const scale = opts.scale || 2.0;
      const topRatio = typeof opts.topRatio === 'number' ? opts.topRatio : 0.45; // верхняя часть картинки
      const contrast = opts.contrast || 1.3;
      const brightness = opts.brightness || 1.0;

      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => {
          // создаём canvas увеличенного размера
          const fullW = Math.round(img.naturalWidth * scale);
          const fullH = Math.round(img.naturalHeight * scale);
          const tmp = document.createElement('canvas');
          tmp.width = fullW;
          tmp.height = fullH;
          const tctx = tmp.getContext('2d');
          tctx.filter = `grayscale(1) contrast(${contrast}) brightness(${brightness})`;
          tctx.drawImage(img, 0, 0, fullW, fullH);

          // теперь кропим верхнюю часть
          const cropH = Math.round(fullH * topRatio);
          const c = document.createElement('canvas');
          c.width = fullW;
          c.height = cropH;
          const ctx = c.getContext('2d');
          // draw the top part
          ctx.putImageData(tctx.getImageData(0,0,fullW,cropH), 0, 0);

          // небольшой усилитель резкости/контуров (unsharp-like)
          // для простоты: нарисуем слегка увеличенную версию (не усложняем)
          // возвращаем dataUrl + размеры
          resolve({ dataUrl: c.toDataURL('image/png', 0.9), width: c.width, height: c.height });
        };
        img.onerror = reject;
        img.src = dataUrl;
      });
    }

    // -------------------- извлечение из Tesseract результата --------------------
    function extractScoresFromTess(tessResult, imgW, imgH) {
      const words = (tessResult?.data?.words || []).map(w => {
        // некоторые версии tesseract.js используют bbox.x0/x1..., другие - bbox (с разными именами).
        // нормализуем bbox
        const bbox = w.bbox || w.box || {};
        const x0 = bbox.x0 != null ? bbox.x0 : (bbox.x || bbox.x0 || 0);
        const x1 = bbox.x1 != null ? bbox.x1 : (bbox.x + bbox.w || bbox.x1 || 0);
        const y0 = bbox.y0 != null ? bbox.y0 : (bbox.y || bbox.y0 || 0);
        const y1 = bbox.y1 != null ? bbox.y1 : (bbox.y + bbox.h || bbox.y1 || 0);

        const text = (w.text || w.word || '').trim();
        const conf = w.confidence != null ? w.confidence : (w.conf || 0);
        return { text, x0, x1, y0, y1, conf };
      });

      // чистые цифровые токены (оставляем только цифры)
      const digitTokens = words
        .map(w => {
          const onlyDigits = (w.text || '').replace(/[^\d]/g, '');
          return { ...w, digits: onlyDigits, num: onlyDigits ? parseInt(onlyDigits, 10) : null };
        })
        .filter(t => t.digits && /^\d{1,3}$/.test(t.digits) && t.num > 0 && t.conf >= 20); // отбросим очень низкое доверие

      // если нет цифровых токенов, fallback: из полного текста
      if (digitTokens.length === 0) {
        const txt = (tessResult?.data?.text || '').replace(/\s+/g, ' ');
        const ints = (txt.match(/\d{1,3}/g) || []).map(n => parseInt(n,10)).filter(n => n>0 && n<=300);
        if (ints.length >= 2) {
          return { team1: 'Команда 1', score1: ints[ints.length-2], team2: 'Команда 2', score2: ints[ints.length-1], rawText: txt };
        } else {
          return { error: 'Не удалось найти числа в распознанном тексте', rawText: tessResult?.data?.text || '' };
        }
      }

      // найдём правую границу всех слов (максимум x1)
      const maxX = Math.max(...words.map(w => w.x1 || 0));
      // будем считать "правой колонкой" те токены, которые расположены в пределах rightZonePercent от правого края.
      const rightZonePercent = 0.30; // 30% от ширины - подстраивай при необходимости
      const xThreshold = maxX - imgW * rightZonePercent;

      // кандидаты справа (первичная фильтрация)
      let rightCandidates = digitTokens.filter(t => t.x1 >= xThreshold);

      // Если справа мало кандидатов, расширим (например, возьмём просто самые правые 6 токенов)
      if (rightCandidates.length < 2) {
        rightCandidates = digitTokens.sort((a,b) => b.x1 - a.x1).slice(0, 8);
      }

      // Теперь из rightCandidates возьмём две строки (по Y): первые две по y0 (они будут сверху и снизу — 2 команды)
      const byY = [...rightCandidates].sort((a,b) => a.y0 - b.y0);
      // Удаляем дубли по очень близкой Y (на случай, если одно число распалось на несколько токенов)
      const uniqByRow = [];
      for (const t of byY) {
        if (!uniqByRow.some(u => Math.abs(u.y0 - t.y0) < Math.max(6, (t.y1 - t.y0) * 0.6))) {
          uniqByRow.push(t);
        }
        if (uniqByRow.length >= 2) break;
      }

      let chosen = uniqByRow;
      // если всё ещё меньше 2, просто возьмём два самых правых
      if (chosen.length < 2) {
        chosen = digitTokens.sort((a,b) => b.x1 - a.x1).slice(0,2);
      }

      // гарантируем порядок: первая (team1) выше по экрану (меньше y)
      chosen.sort((a,b) => a.y0 - b.y0);

      // для каждого выбранного числа попытаемся собрать имя команды слева на той же "строке"
      function collectNameLeft(token) {
        const centerY = (token.y0 + token.y1) / 2;
        const height = Math.max(6, token.y1 - token.y0);
        // слова слева, в пределах вертикального диапазона, и с буквами
        const leftWords = words.filter(w => {
          const wCenterY = (w.y0 + w.y1) / 2;
          const sameRow = Math.abs(wCenterY - centerY) <= Math.max( height * 1.6, 12 );
          const isLeft = (w.x1 || 0) < (token.x0 || 0) - 4; // немного левее
          const hasLetters = /[A-Za-zА-Яа-яЁё]/.test(w.text || '');
          return sameRow && isLeft && hasLetters;
        }).sort((a,b) => a.x0 - b.x0);
        if (leftWords.length === 0) return null;
        // соединяем, убираем лишние цифры/символы
        const name = leftWords.map(w => w.text.replace(/[0-9\[\]\(\)•●\-–►✦★]/g,'').trim()).filter(Boolean).join(' ');
        return name || null;
      }

      const team1Name = collectNameLeft(chosen[0]) || 'Команда 1';
      const team2Name = collectNameLeft(chosen[1]) || 'Команда 2';
      const score1 = chosen[0].num;
      const score2 = chosen[1].num;

      // дополнительно: если выбранные числа выглядят как "малые" (например 1 и 81) и есть числа побольше справа,
      // попробуем альтернативный способ: взять последние два целых числа из всего распознанного текста (но фильтруя коэффициенты)
      if ((score1 < 5 && score2 > 50) || (score1 === 1 && score2 > 70)) {
        const fullInts = (tessResult?.data?.text || '').match(/\d{1,3}/g) || [];
        const intsFiltered = fullInts.map(n=>parseInt(n,10)).filter(n => n>5 && n<=300); // избегаем коэф ~1, хз
        if (intsFiltered.length >= 2) {
          // берем последние два
          const a = intsFiltered[intsFiltered.length - 2];
          const b = intsFiltered[intsFiltered.length - 1];
          // только если это более правдоподобно
          if (Math.abs(a - score1) > 10 || Math.abs(b - score2) > 10) {
            return { team1: team1Name, score1: a, team2: team2Name, score2: b, rawText: tessResult?.data?.text || '' };
          }
        }
      }

      return { team1: team1Name, score1, team2: team2Name, score2, rawText: tessResult?.data?.text || '' };
    }

    // -------------------- отрисовка --------------------
    function renderResult(obj) {
      if (obj.error) {
        output.innerHTML = `<div style="color:crimson">${escapeHtml(obj.error)}</div><pre class="small">${escapeHtml(obj.rawText || '')}</pre>`;
        return;
      }
      const leader = (obj.score1 > obj.score2) ? 'team1' : (obj.score2 > obj.score1 ? 'team2' : 'draw');
      const t1Class = leader === 'team1' ? 'ok' : '';
      const t2Class = leader === 'team2' ? 'ok' : '';
      output.innerHTML = `
        <div><strong class="${t1Class}">${escapeHtml(obj.team1)}:</strong> <span style="font-size:20px">${escapeHtml(String(obj.score1))}</span></div>
        <div style="margin-top:6px"><strong class="${t2Class}">${escapeHtml(obj.team2)}:</strong> <span style="font-size:20px">${escapeHtml(String(obj.score2))}</span></div>
        <details style="margin-top:12px"><summary class="small">Показать распознанный текст</summary><pre class="small">${escapeHtml(obj.rawText || '')}</pre></details>
      `;
    }

    function escapeHtml(s) {
      return String(s || '').replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
    }
  </script>
</body>
</html>
